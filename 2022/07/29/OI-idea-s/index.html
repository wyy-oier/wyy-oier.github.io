<head>
    <title> OI idea(s) - WyyOIer </title>
  	<link rel="stylesheet" href="/css/main.css">
  	<link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <script type = "text/javascript" async src="/javascript/main.js"></script>
    <script id="MathJax-script" async src="/javascript/math/tex-mml-chtml.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>


   <!-- <script type="text/javascript" src="/javascript/codeBlocks/codeBlockFuction.js"></script> -->
   <!-- <script type="text/javascript" src="/javascript/codeBlocks/codeCopy.js"></script> -->
   <!-- <script type="text/javascript" src="/javascript/codeBlocks/clipboard.min.js"></script> -->
   <!-- <script type="text/javascript" src="/javascript/codeBlocks/codeShrink.js"></script> -->
   <!-- <style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style> -->

    <!-- <link rel="stylesheet" href="/highlight/styles/atom-one-dark.min.css"> -->
    
    <!-- <link rel="stylesheet" href="/css/bootstrap.min.css"> -->
    <script id="Valine" src='https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js'></script>
<meta name="generator" content="Hexo 6.2.0"><link rel="stylesheet" href="/css/prism-sh.css" type="text/css"></head>

<body>


<div id = "background">
    <div id = "index">
        <div id="menu">

    <div style="text-align: center;font-size: 32px;font-family: consolas;">
        <p>WyyOIer</p>
    </div>

    <div style="height: 150px;float: up;display: flex;flex-direction: column;align-items: center;">
        <div id="headstyle">
            
        </div>
    </div>
	
    <div style="height: 50px;width: 30%;float: left;text-align: center;">
        <text id = "pcount" title = "文章数" style = "font-family: consolas;font-size: 20px;">15</text>
    </div>

    <div style="height: 50px;width: 30%;float: left;text-align: center;">
        <text id = "commentcount" title = "评论数" style = "font-family: consolas;font-size: 20px;">0</text>
    </div>

    <div style="height: 50px;width: 40%;float: left;text-align: center;">
        <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/159610">
        <img src="https://www.luogu.com.cn/favicon.ico" alt="洛谷" width="24" height="24"></a>
        &nbsp; 
        <a target="_blank" rel="noopener" href="https://codeforces.com/profile/WyyOIer">
        <img src="https://codeforces.com/favicon.ico" alt="CF" width="24" height="24"></a>
    </div>


    <div class="list-group">
        <a class="list-group-item" href="/"><i class="fa fa-home fa-fw"></i>&nbsp; 首页</a>
        <a class="list-group-item" href="/about"><i class="fa fa-user fa-fw"></i>&nbsp; 关于</a>
        <a class="list-group-item" href="/links"><i class="fa fa-link fa-fw"></i>&nbsp; 友链</a>
        <a class="list-group-item" onclick = "Search()"><i class="fa fa-search fa-fw"></i>&nbsp; 搜索</a>
        <a class="list-group-item" href="/template"><i class="fa fa-file-code-o fa-fw"></i>&nbsp; 模板</a>
        <a class="list-group-item" href="/config"><i class="fa fa-cog fa-fw"></i>&nbsp; 设置</a>
    </div>

    <script>
        function changemusicid(){
            var v = document.getElementById("num").value, text, f = 0;
            if(v == null || v == "") {
            text = "输入不能为空。";
            f = 1;
            }
            if(f == 0) document.getElementById("music").innerHTML= '<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=250 height=95 src="//music.163.com/outchain/player?type=2&id=' + v + '&auto=0&height=66"></iframe> ';
            else document.getElementById("musictext").innerHTML = text;
        }
    </script>

    <div style="height: 13%;width: 30%;float: left" id="music">
    <!-- <input id = "num" placeholder = "输入网易音乐 id，如 480517594" style = "width: 230px;"> -->
    <!-- <button type="button" onclick="changemusicid()">提交</button> -->
    <!-- <p id = "musictext"></p> -->
    </div>

</div>


    </div>

    

    


    

        <div id = "article">
            <div id = "post-title"> OI idea(s) </div>
            <div id = "post-author"> By WyyOIer | </div>
            <div id = "post-date" title = "发布时间"> 2022-07-29 13:24:02 / </div>
            <div id = "post-updated" title = "更新时间"> 2022-09-11 16:50:10 </div>
            <span class = "leancloud_visitors" id = "/2022/07/29/OI-idea-s/">
                <text class="post-meta-item-text">阅读数 </text>
                <i class="leancloud-visitors-count">nan</i>
            </span>
            <br>
            <p>想把 OI 中的方法论总结一下，包括一些常见套路和有意思的 idea，并包括深度理解。</p>
<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><img src="https://s2.loli.net/2022/08/06/GPzijIWxcQq3AuN.png" alt="image.png" style="zoom:50%;" />

<p>矩阵乘法主要用于优化数列或状态的递推。设矩阵大小为 $n\times n$，那么求 $T$ 时刻的局面就是 $\mathcal{O}(n^3\log T)$。如果有 $q$ 次询问，可以预处理所有 $2$ 的整数次幂的矩阵，然后采用一维向量乘矩阵得到答案，复杂度从 $\mathcal{O}(qn^3\log T)$ 优化至 $\mathcal{O}(n^3\log T+qn^2\log T)$。</p>
<p>注意矩阵乘法优化 $dp$ 要保证<strong>每个阶段的转移形式完全相同</strong>。</p>
<h2 id="运算形式"><a href="#运算形式" class="headerlink" title="运算形式"></a>运算形式</h2><p>矩阵乘法一般是两种运算形式叠加使用，记运算符号 $mat(\times,+)$ 的转移形式为：</p>
<p>$res.num_{i,j}+&#x3D;num_{i,k}\times A.num_{j,k}$ </p>
<p>对于运算符号有如下要求：</p>
<ol>
<li>第一种运算满足交换律；</li>
<li>第一种运算满足结合律；</li>
<li>第一种对第二种运算满足分配率。</li>
</ol>
<p>下面列举几种常见符号组合。</p>
<p>$mat(\times,+)$：路径计数</p>
<p>$mat(+,\max)$：最长路</p>
<p>$mat(+,\min)$：最短路</p>
<p>$mat(\text{&amp;},|)$：判图连通</p>
<h2 id="题面形式"><a href="#题面形式" class="headerlink" title="题面形式"></a>题面形式</h2><p>状态很少 $(n-300)$，最终所求数列的项数很大 $(T-10^{18})$，每个位置的转移方式相同，比如有递推公式或<strong>对于每个阶段固定的转移方程</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1613">P1613 跑路</a> $n\le 50,T\le 10^{18}$ ，且每个点的转移方式相同，用 $mat(\text{&amp;},|)$ 判是否连通，然后跑 floyd。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6569">P6569 [NOI Online #3 提高组] 魔法值</a> $n\le100,T\le 2^{32}$，对于每个点的转移，在每一个时刻都只跟它周围点的状态有关，记 $mat_{u,v}$ 表示 $u,v$ 之间是否有边，有边为 $1$，没边为 $0$，写一个 $mat(\text{&amp;},\oplus)$ 矩阵运算再用 $2$ 的整数次幂预处理矩阵优化询问即可。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6772">P6772 [NOI2020] 美食家</a> 拆点构建矩阵，用 $mat(\times,\max)$ 运算，时间复杂度 $O((5n)^3\log T)$。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序的本质：交换逆序对的过程。</p>
<p>一个位置可以被“排序”的充分必要条件：存在关于这个位置的逆序对。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1136D">CF1136D Nastya Is Buying Lunch</a> 可以看作每一对 $(u,v)$ 都是一对可进行相邻交换的逆序对，找到最后一个人 $x$ 能够交换的逆序对 $(y,x)$，当且仅当 $y\sim x$ 之间的一段前缀（可以为空）是 $y$ 的逆序对，后缀（可以为空）是 $x$ 的逆序对，否则就会成为一个对 $y$ 之前的元素的一个阻碍。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1187D">CF1187D Subarray Sorting</a> 考虑 $A$ 换到 $B$ 的充分必要条件。<strong>（往往这一步最难）</strong>我们去考虑排序的本质，能<strong>删</strong>逆序对，那么如果 $B$ 存在的逆序对 $A$ 中没有，那么 $A$ 就<strong>不能加</strong>逆序对到 $B$，那么这就是 <code>YES</code> 的一个必要条件。充分性的证明即我们是否能对于上述情况，能否找到一个操作保证换掉 $B$ 中没出现的逆序对。考虑一种操作方案：从后往前做，对于当前的数，做一遍冒泡排序消除所有不在 $B$ 的逆序对。</p>
<p>所以我们考虑是否会出现这样一种情况：是否在当前的数后有一个位置构成的逆序对出现在 $B$，但之后又出现了一个不出现在 $B$ 的逆序对？（也就是我必须先消除前面在 $B$ 的逆序对，才能消除后面不在 $B$ 的逆序对从而不合法，如果不存在这种情况，那么冒泡就是对的）</p>
<p>首先，不妨设当前的数为 $x$，后面那个出现在 $B$ 中的逆序对为 $y$，不出现在 $B$ 中的逆序对为 $z$，也就是如下的一种局面：</p>
<img src="https://s2.loli.net/2022/08/10/42ResEVF7XCQ8OB.jpg" alt="CF1187D Subarray Sorting-01.jpg" style="zoom:80%;" />

<p>不难发现，当且仅当 $y&lt;z&lt;x$ 时不能采用上述做法，但是最后我们要排成 $z-x-y$ 的形式，这样我们就多了一个 $(z,y)$ 逆序对，所以这种在必要的时候就被判掉了。那么我们也成功的说明了上述的必要条件有恰当的构造方法使得称为 $B$ 序列，变为了充分必要条件，至于最后的判断，属于技术问题，留作口胡。（提示：对于一个数 $x$ 维护其后面的逆序对集是否包含于这个数在 $B$ 中对应的逆序对集）</p>
<h2 id="插旗法"><a href="#插旗法" class="headerlink" title="插旗法"></a>插旗法</h2><p>可以对于一个环上顺序置换最优解问题，从 $n$ 个人到 $n$ 个位置的问题转化成了 $n$ 个旗子到 $1$ 个位置的问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1053">P1053 [NOIP2005 提高组] 篝火晚会</a> </p>
<p>由于不同的环只有 $2n$ 个，枚举每种环，考虑有多少人不在最终局面的位置上，所有取最小即可，复杂度 $\mathcal{O}(n^2)$。</p>
<p>我们不妨考虑，其实就是对于所有情况最小化初始局面和最终局面不在同一位置的人数。如果顺时针和逆时针分开考虑的话，其实就是 $n$ 个循环移位，<strong>循环移位不改变任意两点的相对位置</strong>，所以有了插旗法：首先我们找到 $1$ 的位置是对的最终局面，记为 $P$，然后看每个人从初始局面顺时针走多少步能走到最终局面的对应位置，然后我们就对这个步数的下标查一个旗，表示 $P$ 这个排列顺时针移动一定次数就会让这个插旗的人产生贡献，最后插旗最多的地方即为最优的最终局面，复杂度 $\mathcal{O}(n)$。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U76006">U76006 环上游戏</a></p>
<p>这题还是从初始局面转移到 $2n$ 个最终局面的最优，先考虑顺时针，我们固定 $1$ 的初始位置就是最终局面的位置，记这个局面为 $P$，然后我们在 $i$ 后面 $(i-1)$ 个位置插一个旗，然后想象 $i$ 和旗子一块移动，这样达到最终局面后，所有旗子都到达了 $1$ 位置，现在我们就转化成了所有旗子到某个位置的最小总距离。（因为旗子的位置是与 $1$ 的相对位置，而 $1$ 的位置 $n$ 种任选）</p>
<p>这个有个贪心做法：枚举一个位置把圆切成两边，发现一定是把旗子都切在一边，所以就是把最长段给扔了。</p>
<p>时间复杂度 $\mathcal{O}(n)$。</p>
<h2 id="置换排序模型"><a href="#置换排序模型" class="headerlink" title="置换排序模型"></a>置换排序模型</h2><p>对于一个置换 $p$，以 $i\rightarrow p_i$ 连边，那么就是 $n$ 点 $n$ 边，且每点入度出度均为 $1$，也就是由若干个环组成的图。</p>
<p>考虑对于一个置换，最终的有序状态是 $n$ 个自环，而一次交换可以从一个环拿出一个数使其变为自环，那么操作数即为  $\sum\limits_{i&#x3D;1}^m sz_i-1&#x3D;n-m$，$m$ 为环的个数。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2127">P2127 序列排序</a> 加权的给置换排序的模型，对一个环拆成自环的时候，考虑两种决策：</p>
<ul>
<li>把全局最小先加入这个环中，然后把其它数给拿出去；</li>
<li>直接用环中的最小数把其它数拿出去。</li>
</ul>
<p>考虑环与环之间的决策互不影响，所以两种决策取最优即可。</p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/5671">2020牛客暑期多校训练营（第六场）A</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/BeWild/post-2020-niu-ke-shu-ji-duo-xiao-xun-lian-ying-di-liu-chang-post">https://www.luogu.com.cn/blog/BeWild/post-2020-niu-ke-shu-ji-duo-xiao-xun-lian-ying-di-liu-chang-post</a></p>
<h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><h3 id="山区建小学模型"><a href="#山区建小学模型" class="headerlink" title="山区建小学模型"></a>山区建小学模型</h3><p> $\sum\limits_{i&#x3D;1}^n|x-p_i|$ 或 $\sum\limits_{i&#x3D;1}^n|p_x-p_i|$ 的一般最值问题。取其中位数，可能会用不同的算法维护。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3644">P3644 [APIO2015] 八邻旁之桥</a> </p>
<p>一座桥就是朴素的山区建小学问题，把 $s$ 和 $t$ 都扔到数轴上取中位数算即可。</p>
<p>考虑如果有两座桥。每一个人有两个决策，选 $A$ 桥还是选 $B$ 桥。以桥为分界划分为三部分：</p>
<p><img src="https://s2.loli.net/2022/08/10/yF7AYwzLPfXvd5T.jpg" alt="P3644 _APIO2015_ 八邻旁之桥-01.jpg" style="zoom:67%;" />考虑如果某个人的起点在 $I$ 区或 $III$ 区，那么对于这个人，一定可以选靠近这个人起点 的桥，因为远离的桥不优。那么只需考虑如果一个人的起点和终点都在 $II$ 区的情况。</p>
<p>设两座桥的位置为 $x,y$ 且 $x&lt;y$，起点的位置为 $s$，终点的位置为 $t$。</p>
<img src="https://s2.loli.net/2022/08/10/oF2AZsRnB5tHIav.jpg" alt="P3644 _APIO2015_ 八邻旁之桥-02.jpg" style="zoom:67%;" />

<p>那么走 $A$ 桥优于 $B$ 桥，当且仅当：</p>
<p>$(s-x)+(t-x)&lt;(y-s)+(y-t)$</p>
<p>$\Rightarrow s+t&lt;x+y$</p>
<p>也就是对于所有 $s+t&lt;x+y$ 的人，都走 $A$ 桥，反之都走 $B$ 桥。也就是我们去枚举所有的断点 $s+t$，这样两边就是 $k&#x3D;1$ 的朴素山区建小学，我们动态维护两边的中位数，时间复杂度为 $\mathcal{O}(n\log n)$。</p>
<p><strong>（思考）</strong>在推出 $s+t&lt;x+y$，一直陷入一个误区：当我们枚举 $s+t$ 也就确定了 $x+y$，但可能两边所划分的中位数，也就是两座桥的具体位置不能为 $x+y$ 该如何解决？</p>
<p><strong>（解答）</strong>经过教练的指导，发现这个式子的意义是，我们找到了一种排序方式（按 $s+t$ 排序）使得对于小于 $x+y$ 的 $A$ 桥，大于 $x+y$ 的一定走 $B$ 桥，<strong>那么我们不再关心桥的具体位置，而是最优解的形式一定为以 $s+t$ 排序的前缀走 $A$ 桥，$s+t$ 的后缀走 $B$ 桥</strong>，这样两边山区建小学一定<strong>不会丢失最优解</strong>。</p>
<p><strong>（思想）</strong>对于一个要求较强的结论，考虑退而求其次是否更容易地使用。</p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="冰红茶模型-x2F-排队模型"><a href="#冰红茶模型-x2F-排队模型" class="headerlink" title="冰红茶模型&#x2F;排队模型"></a>冰红茶模型&#x2F;排队模型</h2><p>在一个集合中进行若干次决策，对于每一次决策所选中的点，又会补充一个劣于当前解的后继（重点），这样每次必然是选择最优解，然后更新新后继，用优先队列维护。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U130967">U130967 冰红茶(tea)</a> 冰红茶模型模板题。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1315">P1315 [NOIP2011 提高组] 观光公交</a> </p>
<p>考虑对第 $i$ 站使用加速器，影响了一段从第 $i$ 站开始，到之后的一站之间<strong>下车</strong>的人，记为 $p_i$。</p>
<p>如果使用加速器，一定会导致 $p_i$ 减小（到达 $p_i$ 站的时间更短），所以下次再选 $i$ 时答案变劣，所以冰红茶即可。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5283">P5283 [十二省联考 2019] 异或粽子</a> $n$ 个班排队模型的例题，省选也是有考这些基础算法的题的。</p>
<h2 id="相邻交换法"><a href="#相邻交换法" class="headerlink" title="相邻交换法"></a>相邻交换法</h2><p>相邻交换 yyds</p>
<p>使用相邻交换法的前提是推一个<strong>具有传递性</strong> $(a&lt;b,b&lt;c\Rightarrow a&lt;c)$ 的比较关系，排好序后即能轻易的得出一系列最优决策。</p>
<h3 id="拆-max-min-法"><a href="#拆-max-min-法" class="headerlink" title="拆 $\max,\min$ 法"></a>拆 $\max,\min$ 法</h3><p>$a&gt;\max(b,c)\Leftrightarrow a&gt;b\text{ and }a&gt;c$</p>
<p>$\max(b,c)&gt;a\Leftrightarrow b&gt;a\text{ or } c&gt;a$</p>
<p>$a&gt;\min(b,c)\Leftrightarrow a&gt;b\text{ or }a&gt;c$</p>
<p>$min(b,c)&gt;a\Leftrightarrow b&gt;a\text{ and }c&gt;a$</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1080">P1080 [NOIP2012 提高组] 国王游戏</a></p>
<p>设前缀积 $mu_i&#x3D;\prod\limits_{j&#x3D;1}^i a_i$，那么每个人的金币数为 $\lfloor\dfrac{mu_{i-1}}{b_i}\rfloor$。</p>
<p>我们取出一个二元组 $(i,j)$，其中 $i&lt;j$，本题中并不能得出越靠后的大臣获得的金币越多的结论。</p>
<p>我们设 $1\sim i-1$  大臣左手的数的积为 $mu_1$，$i+1\sim j-1$ 大臣左手的数的积为 $mu_2$。</p>
<p>在 $i,j$ 交换前，$i$ 获得的金币数 $\lfloor\dfrac{mu_1}{b_i}\rfloor$，$j$ 获得的金币数 $\lfloor\dfrac{mu_1\cdot a_i\cdot mu_2}{b_j}\rfloor$。</p>
<p>在 $i,j$ 交换后，$i$ 获得的金币数 $\lfloor\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i}\rfloor$，$j$ 获得的金币数 $\lfloor\dfrac{mu_1}{b_j}\rfloor$。</p>
<p>相邻交换法的常见套路，不妨设交换前的答案优于交换后的答案。</p>
<p>则有 $\max(\lfloor\dfrac{mu_1}{b_i}\rfloor, \lfloor\dfrac{mu_1\cdot a_i\cdot mu_2}{b_j}\rfloor)&lt;\max(\lfloor\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i}\rfloor, \lfloor\dfrac{mu_1}{b_j}\rfloor)$。</p>
<p>其中下取整不影响答案，去掉后变为 $\max(\dfrac{mu_1}{b_i}, \dfrac{mu_1\cdot a_i\cdot mu_2}{b_j})&lt;\max(\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i}, \dfrac{mu_1}{b_j})$。</p>
<p>用拆 $\max$ 法，$\Leftrightarrow \max(\dfrac{mu_1}{b_i}, \dfrac{mu_1\cdot a_i\cdot mu_2}{b_j})&lt;\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i}\text{ or }\max(\dfrac{mu_1}{b_i}, \dfrac{mu_1\cdot a_i\cdot mu_2}{b_j})&lt;\dfrac{mu_1}{b_j}$</p>
<p>$\Leftrightarrow (①\dfrac{mu_1}{b_i}&lt;\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i}\text{ and }②\dfrac{mu_1\cdot a_i\cdot mu_2}{b_j}&lt;\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i})\text{ or }(③\dfrac{mu_1}{b_i}&lt;\dfrac{mu_1}{b_j}\text{ and }④\dfrac{mu_1\cdot a_i\cdot mu_2}{b_j}&lt;\dfrac{mu_1}{b_j})$</p>
<p>现在我们就把 $\max$ 拆成了两两的元素比较和逻辑运算，接下来我们来看看有没有显然成立或不成立的逻辑式。</p>
<p>不难发现，①式显然成立，④式显然不成立，这样我们神奇的发现：</p>
<p>$\Leftrightarrow ②\dfrac{mu_1\cdot a_i\cdot mu_2}{b_j}&lt;\dfrac{mu_1\cdot a_j\cdot mu_2}{b_i}$</p>
<p>$\Leftrightarrow a_i\cdot b_i&lt;a_j\cdot b_j$</p>
<p>没错，我们的得到了一个简单的式子，并且此式满足传递性，于是排序后得到的即为我们所求的最优解。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2123">P2123 皇后游戏</a></p>
<p>国王游戏的加强版，一个更难推的相邻交换。</p>
<p>本题可以得出越靠后的大臣奖金越多的结论。</p>
<p>这次我们用相邻两个人 $(i,j)$ 比较，其中 $j&#x3D;i+1$，设 $\sum\limits_{i&#x3D;1}^{i-1} a_i$ 为 $s$，那么在交换前 $c_j&gt;c_i$，$c_i&#x3D;\max(c_{i-1},s+a_i)+b_i$，$c_j&#x3D;\max(\max(c_{i-1},s+a_i)+b_i,s+a_i+a_j)+b_j$ ，交换后 $c_j&lt;c_i$，$c_j&#x3D;\max(c_{i-1},s+a_j)+b_j$，$c_i&#x3D;\max(\max(c_{i-1},s+a_j)+b_j,s+a_j+a_i)+b_i$。</p>
<p>不妨设交换前的答案不劣于交换后的答案，则有：</p>
<p>$\max(\max(c_{i-1},s+a_i)+b_i,s+a_i+a_j)+b_j\le\max(\max(c_{i-1},s+a_j)+b_j,s+a_j+a_i)+b_i$</p>
<p>$\Leftrightarrow \max(\max(c_{i-1},s+a_i)+b_i+b_j,s+a_i+a_j+b_j)\le\max(\max(c_{i-1},s+a_j)+b_j+b_i,s+a_j+a_i+b_i)$</p>
<p>$\Leftrightarrow \max(c_{i-1}+b_i+b_j,s+a_i+b_i+b_j,s+a_i+a_j+b_j)\le\max(c_{i-1}+b_i+b_j,s+a_j+b_i+b_j,s+a_i+a_j+b_i)$</p>
<p>两边的 $\max$ 中各有三个元素，拆起来麻烦怎么办？</p>
<p>考虑两边有相同的元素 $c_{i-1}+b_i+b_j$，那么证明一个结论：$\max(a,b)\le\max(a,c)\Rightarrow b\le c$。</p>
<ul>
<li>如果 $b\le c$，则已经满足条件；</li>
<li>如果 $b&gt;c$，那么 $b\le a$，交换后同样满足。</li>
</ul>
<p>综上可知结论成立。那么进行一步简化：</p>
<p>$\Rightarrow \max(s+a_i+b_i+b_j,s+a_i+a_j+b_j)\le\max(s+a_j+b_i+b_j,s+a_i+a_j+b_i)$</p>
<p>然后就可以进行愉快的拆 $\max$ 环节了！</p>
<p>$\Leftrightarrow \max(s+a_i+b_i+b_j,s+a_i+a_j+b_j)\le s+a_j+b_i+b_j\text{ or }\max(s+a_i+b_i+b_j,s+a_i+a_j+b_j)\le s+a_i+a_j+b_i$</p>
<p>$\Leftrightarrow (s+a_i+b_i+b_j\le s+a_j+b_i+b_j\text{ and }s+a_i+a_j+b_j\le s+a_j+b_i+b_j)\text{ or }(s+a_i+b_i+b_j\le s+a_i+a_j+b_i\text{ and }s+a_i+a_j+b_j\le s+a_i+a_j+b_i)$</p>
<p>$\Leftrightarrow (a_i\le a_j\text{ and }a_i\le b_i)\text{ or }(b_j\le a_j\text{ and }b_j\le b_i)$</p>
<p>上述条件并不满足传递性，所以我们尝试转化排序方式，使得 $\forall i,j\in [1,n],i&lt;j$，都能满足上述条件。</p>
<p>观察到 $\text{or}$ 的两边都有一个 $a$ 和 $b$ 一起的比较，那么我们尝试先按此分组。</p>
<p>如果 $a_i&lt;b_i$，分到 $1$ 组；</p>
<p>如果 $a_i&#x3D;b_i$，分到 $2$ 组；</p>
<p>如果 $a_i&gt;b_i$，分到 $3$ 组。</p>
<p>在 $1$ 组中的数，可以同时再去满足 $a_i&lt;a_j$，按 $a$ 升序排序，在 $2$ 组中的数，不满足上述条件，可以随意排序，在 $3$ 组中的数，可以同时再去满足 $b_j&lt;b_i$，按 $b$ 降序排序。</p>
<p>那么关键的问题是组与组之间的排序。这里给出排序方式：按 $1,2,3$ 组排序即可。</p>
<p>证明一下：如果想要证明上述排序方法成立，只需保证按此方法排序后 $\forall i,j\in [1,n],i&lt;j$，都能满足上述条件，由于组内已经满足，只需考虑组间。</p>
<p>考虑 $1$ 组和 $2$ 组，则有，$a_i\le b_i,a_j&#x3D;b_j$。假设可以交换，即不满足上述条件。若不满足条件，则 $a_i\le a_j$ 不能成立，即 $a_i&gt;a_j$，$b_j\le b_i$ 也不能成立，即 $b_j&gt; b_i$，整理条件可得矛盾。</p>
<p>其它情况同理，最终可以保证排序的正确性。</p>
<h2 id="贪心反悔"><a href="#贪心反悔" class="headerlink" title="贪心反悔"></a>贪心反悔</h2><p>一大常用的贪心套路。大体流程是优先满足时间较早的决策，在不能满足当前决策的情况下，在已选的决策集合中找到最不优的，然后替换。在正确性下，我们保证：每一次反悔操作不会使答案变劣。</p>
<p>解决的题目一般满足如下性质：</p>
<ul>
<li>题目有最优子结构性质（即无后效性）</li>
<li>容易维护决策的集合的性质（即可以方便的反悔）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2209">P2209 [USACO13OPEN]Fuel Economy S</a></p>
<p>经典反悔贪心，因为每个加油站都可加无限多的油，想象油箱中每种价格的油是分层的，那么在到达每一个加油站的时候，用此加油站的油替换掉所有在油箱中价钱高于当前加油站价格的油，并把油箱加满，此过程即为反悔。在行走的过程中，优先消耗便宜的油，这样我们就维护了整个过程，到达终点后要把多的油退掉。</p>
<p>时间复杂度为 $\mathcal{O}(n\log n)$。</p>
<p>本题还有一个加强版，请见<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1238G">CF1238G</a>，此题中每一站的供应存在限制。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF865D">CF865D Buy Low Sell High</a></p>
<p>对于一个股票，在买入的时候我们可以看作无代价买入，只有卖出的时候才获得收益。</p>
<p>例如我们已经购入了价格为 $x$ 的股票，现在以 $y$ 的价格卖出，此时我们的收益获得了 $y-x$。</p>
<p>考虑我们如何进行反悔操作。对于价格为 $x$ 的股票，我们要将 $y$ 的价格卖出修改为以 $z$ 的价格卖出，即收益从 $y-x$ 变为 $z-x$，变化了 $z-y$。基于此，我们维护一个小根堆，对于当天的价格 $p$，我们首先将 $p$ 插入，代表原物品，如果 $p$ 还能大于堆中的最小值的话，那么我们就可以先获得 $p-q.top()$ 的代价，然后再次插入 $p$ 这个价格，代表可用作被反悔的物品，这样每次的购买就既有可能是对于原价买入物品的卖出，也有可能是已经被卖出物品的反悔操作。</p>
<p>一个问题：插入两次物品会不会出现不合法的情况，能不能只插入一次。</p>
<p>插入两次同一个物品的目标无非就是两个物品都有可能会用到，我们不妨分析两个物品都用到的情况。</p>
<p>对于一个股票在 $p_i$ 买入，在 $p_j$ 卖出，那么此时堆里存有两个 $p_j$，分别代表 “在 $p_i$ 买入，在 $p_j$ 卖出的决策”和“我有一个价值为 $p_j$ 的股票已经买入”，那么如果在 $p_k$ 的时候堆顶为 $p_j$（如果堆顶被弹出，下一个堆顶也是 $p_j$），我们首先拿出”在 $p_i$ 买入，在 $p_j$ 卖出的决策”，改为”在 $p_i$ 买入，在 $p_k$ 卖出的决策”，经此修改后，$p_j$ 就成为了一个既没有买也没有卖的元素，那么在下一次 $p_l$ 取出 $p_j$ 的时候，即为”在 $p_j$ 买入，在 $p_l$ 卖出的决策”，这样插入两次物品不仅能够保证合法，还是保留最优解的充分条件。</p>
<h2 id="超级钢琴模型"><a href="#超级钢琴模型" class="headerlink" title="超级钢琴模型"></a>超级钢琴模型</h2><p>超级钢琴其实类似冰红茶，最基础的情况，两两点之间有一个代价，求代价的最大值。一个点 $i$ 我们对应若干个决策区间，先预处理出区间中的与 $i$ 所得代价的最大值并记录位置 $p$，那么在选择这个之后，将当前的决策区间 $[l,r]$ 拆成 $[l,p-1]$ 与 $[p+1,r]$，因为 $p$ 是 $[l,r]$ 中的最大值，所以分成 $[l,p-1]$ 和 $[p+1,r]$ 后的答案一定要劣于 $p$，这就是一个冰红茶的过程。</p>
<p>此类题所有的特定条件：</p>
<ul>
<li>求一定点所构成的代价的最值</li>
<li>容易维护决策区间的最大值</li>
</ul>
<p>超级钢琴模型的运用灵活，作者见过的题不多，希望以后遇到后还能认真总结。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2048">P2048 [NOI2010] 超级钢琴</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U125195">U125195 大战杀马特(smart)</a></p>
<h2 id="时光倒流"><a href="#时光倒流" class="headerlink" title="时光倒流"></a>时光倒流</h2><p>时光倒流其实是一类经典的思想，具体是如果按正向时间不好维护决策的时候，看看倒序解决能不能有事半功倍的效果。</p>
<p>例如正序的删点维护连通性，我们可以改为倒序加点，这样就可以轻易的维护。</p>
<p>在贪心上，时光倒流有时也可以起到奇效。</p>
<p>适用的题为<strong>正序没有最优子结构性质但倒序有最优子结构性质</strong>的题目。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1954">P1954 [NOI2010] 航空管制</a></p>
<p>考虑按时间正序做需要维护删除操作，但显然删除并不好维护，那么考虑时光倒流变成加点，再将第二类限制反过来，用拓扑随便贪心做一下即可，复杂度 $\mathcal{O}(nm)$。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3826">P3826 [NOI2017] 蔬菜</a></p>
<p>正序我们同样需要维护讨厌的删除操作，如果改为倒序，“每天少 $x_i$ 单位蔬菜”就变成了“蔬菜从 $app_i$ 天开始每天多 $x_i$ 单位蔬菜”，然后我们就可以在每天贪心的取最大的 $m$ 个。</p>
<p>考虑现在求的答案是所有天数的答案，即 $ans_{100000}$，那么如何求其它天数 $1\sim 99999$。</p>
<p>不难发现，选择了售卖的菜之后，我可以随意的安排这些菜的售卖顺序，因为越往后菜越多，所以在前面的天数这些菜并不会消失，所以从第 $j$ 天推到第 $j-1$ 天时我们只要去掉最便宜的 $m$ 个菜就行。</p>
<p>注意可能在倒序做的时候有的天数可能卖不到 $m$ 个菜，但正序的时候由于这些售卖操作都可以理解为在前 $j$ 天的紧凑操作（即每天卖菜数不存在浪费），所以当且仅当 $m\times j$ 小于现在卖过的菜的总量，我们才需要去删除多余的菜。</p>
<h2 id="双序列匹配"><a href="#双序列匹配" class="headerlink" title="双序列匹配"></a>双序列匹配</h2><p>给两个序列 $a$ 和 $b$，在改变 $a,b$ 的顺序后使得一个计算代价的函数 $f(a,b)$ 得到最值，这种一般可以用贪心的匹配得到答案。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1966">P1966 [NOIP2013 提高组] 火柴排队</a></p>
<p>给定序列 $a,b$，任意改变 $a,b$ 的顺序，求 $\sum(a_i-b_i)^2$ 的最小值。</p>
<p>最基础的双序列匹配问题，不考虑交换次数的话，将 $a,b$ 都按升序排列得到的即为最小值。交换次数最小我们只需将 $b$ 数组映射到 $a$ 数组，然后求逆序对即可。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1084">P1084 [NOIP2012 提高组] 疫情控制</a></p>
<p>这应该算是一个贪心双序列匹配的经典好题了，首先我们不妨二分出一个时间，代表花费的最长时间，那么我们首先可以将所有军队向上跳，显然如果军队能向上跳，那么向上跳肯定不劣。</p>
<p>在所有的军队都向上跳完后，有的叶子肯定没有被军队挡住，我们把这些叶子对应的根的儿子的子树标记，代表这个子树需要被帮助，找到了所有需要帮助的子树后，我们要去用已经到达根的儿子的点的一些军队且还有空余时间走到其它的树来帮助别的子树。（注意当这个在根的儿子的军队去帮助别的子树的时候，它自己这棵子树可能就有拦不住疫情了）</p>
<p>考虑如果一个在根的儿子的军队走到根了之后却不能原路返回再走回自己，且当这个军队走了之后这个子树会失控，那么这个军队应不应该去帮助别人？</p>
<p>如果这个子树帮助别人，那么一定还需要另一个子树上的军队来帮助它，那么我们不如让这个子树的军队不动，这样我们用了更小代价去防控了一个更难防控的子树，这样会更优一些。</p>
<p>最后我们就找到了所有能动的军队和需要被帮助的子树，把距离处理出来，然后双序列贪心匹配，看能不能将帮助所有子树。</p>
<p>时间复杂度 $\mathcal{O}(n\log n\log w)$。</p>

            <div id="vcomments"></div>
        </div>

        <div id = "toc">
        </div>

        <script>
            new Valine({
                el: '#vcomments',
                appId: 'CEGJD6I3uLgJeTF6fPsqgGmw-gzGzoHsz',
                appKey: 'R3wowhGv7IL3peB3tT06CjzS',
                visitor: true,
                master: '28a6ec927125219298a15dcb5c104f67'
            })
        </script>

    

</div>

</body>