<head>
    <title> Codeforces Contest Practice - WyyOIer </title>
  	<link rel="stylesheet" href="/css/main.css">
  	<link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <script type = "text/javascript" async src="/javascript/main.js"></script>
    <script id="MathJax-script" async src="/javascript/math/tex-mml-chtml.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>


   <!-- <script type="text/javascript" src="/javascript/codeBlocks/codeBlockFuction.js"></script> -->
   <!-- <script type="text/javascript" src="/javascript/codeBlocks/codeCopy.js"></script> -->
   <!-- <script type="text/javascript" src="/javascript/codeBlocks/clipboard.min.js"></script> -->
   <!-- <script type="text/javascript" src="/javascript/codeBlocks/codeShrink.js"></script> -->
   <!-- <style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style> -->

    <!-- <link rel="stylesheet" href="/highlight/styles/atom-one-dark.min.css"> -->
    
    <!-- <link rel="stylesheet" href="/css/bootstrap.min.css"> -->
    <script id="Valine" src='https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js'></script>
<meta name="generator" content="Hexo 6.2.0"><link rel="stylesheet" href="/css/prism-sh.css" type="text/css"></head>

<body>


<div id = "background">
    <div id = "index">
        <div id="menu">

    <div style="text-align: center;font-size: 32px;font-family: consolas;">
        <p>WyyOIer</p>
    </div>

    <div style="height: 150px;float: up;display: flex;flex-direction: column;align-items: center;">
        <div id="headstyle">
            
        </div>
    </div>
	
    <div style="height: 50px;width: 30%;float: left;text-align: center;">
        <text id = "pcount" title = "文章数" style = "font-family: consolas;font-size: 20px;">20</text>
    </div>

    <div style="height: 50px;width: 30%;float: left;text-align: center;">
        <text id = "commentcount" title = "评论数" style = "font-family: consolas;font-size: 20px;">0</text>
    </div>

    <div style="height: 50px;width: 40%;float: left;text-align: center;">
        <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/159610">
        <img src="https://www.luogu.com.cn/favicon.ico" alt="洛谷" width="24" height="24"></a>
        &nbsp; 
        <a target="_blank" rel="noopener" href="https://codeforces.com/profile/WyyOIer">
        <img src="https://codeforces.com/favicon.ico" alt="CF" width="24" height="24"></a>
    </div>


    <div class="list-group">
        <a class="list-group-item" href="/"><i class="fa fa-home fa-fw"></i>&nbsp; 首页</a>
        <a class="list-group-item" href="/about"><i class="fa fa-user fa-fw"></i>&nbsp; 关于</a>
        <a class="list-group-item" href="/links"><i class="fa fa-link fa-fw"></i>&nbsp; 友链</a>
        <a class="list-group-item" onclick = "Search()"><i class="fa fa-search fa-fw"></i>&nbsp; 搜索</a>
        <a class="list-group-item" href="/source"><i class="fa fa-code fa-fw"></i>&nbsp; 代码</a>
        <a class="list-group-item" href="/config"><i class="fa fa-cog fa-fw"></i>&nbsp; 设置</a>
    </div>

    <script>
        function changemusicid(){
            var v = document.getElementById("num").value, text, f = 0;
            if(v == null || v == "") {
            text = "输入不能为空。";
            f = 1;
            }
            if(f == 0) document.getElementById("music").innerHTML= '<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=250 height=95 src="//music.163.com/outchain/player?type=2&id=' + v + '&auto=0&height=66"></iframe> ';
            else document.getElementById("musictext").innerHTML = text;
        }
    </script>

    <div style="height: 13%;width: 30%;float: left" id="music">
    <!-- <input id = "num" placeholder = "输入网易音乐 id，如 480517594" style = "width: 230px;"> -->
    <!-- <button type="button" onclick="changemusicid()">提交</button> -->
    <!-- <p id = "musictext"></p> -->
    </div>

</div>


    </div>

    

    


    

        <div id = "article">
            <div id = "post-title"> Codeforces Contest Practice </div>
            <div id = "post-author"> By WyyOIer | </div>
            <div id = "post-date" title = "发布时间"> 2022-02-02 17:03:52 / </div>
            <div id = "post-updated" title = "更新时间"> 2022-08-18 14:25:02 </div>
            <span class = "leancloud_visitors" id = "/2022/02/02/Codeforces-Contest-Practice/">
                <text class="post-meta-item-text">阅读数 </text>
                <i class="leancloud-visitors-count">nan</i>
            </span>
            <br>
            <h1 id="Educational-Codeforces-Round-70-text-1202"><a href="#Educational-Codeforces-Round-70-text-1202" class="headerlink" title="Educational Codeforces Round 70$\text{(1202)}$"></a>Educational Codeforces Round 70$\text{(1202)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Penalty}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$251$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+5}$</td>
<td align="center">$\texttt{-2}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:12}$</td>
<td align="center">$\text{01:04}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>比赛时间：$\text{2022&#x2F;7&#x2F;21 14:30}$</p>
<h2 id="A-You-Are-Given-Two-Binary-Strings…"><a href="#A-You-Are-Given-Two-Binary-Strings…" class="headerlink" title="A. You Are Given Two Binary Strings…"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/problem/A">A. You Are Given Two Binary Strings…</a></h2><p>$\text{Solution:}$</p>
<p>因为是倒序字典序最小，所以我们要尽可能消除靠后的 $1$。</p>
<p>观察到 $k$ 会让 $\text{B}$ 串向左移 $k$ 位，我们判断一下 $\text{B}$ 串的最后一个 $1$，向左移到 $\text{A}$ 串第一个能移到的 $1$ 的位置。</p>
<h2 id="B-You-Are-Given-a-Decimal-String…"><a href="#B-You-Are-Given-a-Decimal-String…" class="headerlink" title="B. You Are Given a Decimal String…"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/problem/B">B. You Are Given a Decimal String…</a></h2><p>$\text{Solution:}$</p>
<p>首先不妨设 $dp_{x,y,i,j}$ 表示用 $x$ 和 $y$，从 $i$ 加到 $j$ 的最小步数。其中 $i,j$ 枚举 $0\sim100$。</p>
<p>$v_{x,y,i,j}$ 表示用 $x,y$，从末位为 $i$ 加到末位为 $j$ 的最小步数，这个可以通过 $dp$ 转移。</p>
<p>最终答案为：$\sum\limits_{i&#x3D;1}^{|s|-1}v_{x,y,s_i,s_{i+1}}$。</p>
<p>时间复杂度 $\mathcal{O}(10\times10\times100\times100+10\times10\times |s|)$。</p>
<h2 id="C-You-Are-Given-a-WASD-string…"><a href="#C-You-Are-Given-a-WASD-string…" class="headerlink" title="C. You Are Given a WASD-string…"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/problem/C">C. You Are Given a WASD-string…</a></h2><p>$\text{Solution:}$</p>
<p>我们不妨假定初始位置为 $(0,0)$，在全程走到的极值坐标 $mix,mxx,miy,mxy$，那么面积为 $(mxx-mix+1)*(mxy-miy+1)$。</p>
<p>因为我们只能添加最多一步，所以答案只有可能变为 $(mxx-mix)*(mxy-miy+1)$ 或 $(mxx-mix+1)*(mxy-miy)$，我们只需判断能否在 $mix&#x2F;miy$ 加 $1$ 的同时 $mxx&#x2F;mxy$ 不变或 $mxx&#x2F;mxy$ 减 $1$ 的同时 $mix&#x2F;miy$ 不变，考场时忘记同时判断另一边不变。</p>
<h2 id="D-Print-a-1337-string…"><a href="#D-Print-a-1337-string…" class="headerlink" title="D. Print a 1337-string…"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/problem/D">D. Print a 1337-string…</a></h2><p>$\text{Solution:}$</p>
<p>考虑构造序列为 $133\underbrace{77\cdots7} _ {cnt_7}\underbrace{33\cdot3}_{cnt_3}7 $。</p>
<p>得到的子序列数量为 $cnt_7+1+\dfrac{(cnt_3+2)(cnt_3+1)-1}{2}$，枚举 $cnt_3$，看 $cnt_7$ 能否满足长度在 $10^5$ 即可。</p>
<h2 id="E-You-Are-Given-Some-Strings…"><a href="#E-You-Are-Given-Some-Strings…" class="headerlink" title="E. You Are Given Some Strings…"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/problem/E">E. You Are Given Some Strings…</a></h2><p>$\text{Solution:}$</p>
<p>我们不妨从文本串找到一个划分点 $i$，分成 $[1,i]$ 和 $[i+1,n]$ 两段，我们可以找所有模式串匹配前半部分的后缀的数量，所有模式串匹配后半部分前缀的数量，将两部分相乘就能得到第 $i$ 位的贡献。由于后半部分等价于前半部分翻转，所以考虑前半部分。</p>
<p>将文本串存入 trie 树，求出 fail 指针，因为失配的定义就是跳到下一个与当前串有最大公共后缀的串的编号，如果 $p$ 能匹配，那么 $fail_p$ 也可以匹配，所以 $p\rightarrow fail_p$ 作为更新，最后遍历文本串，若此时遍历到了第 $i$ 位，匹配到了 $p$ 节点，则有 $f_i&#x3D;ed_p$。</p>
<p>然后将两边都算出来就解决了这道题。</p>
<p>时间复杂度 $\mathcal{O}(|T|+\sum|S|)$。</p>
<p>$\text{Code: }$<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/submission/165291628">Submission #165291628 - Codeforces</a></p>
<h2 id="F-You-Are-Given-Some-Letters…"><a href="#F-You-Are-Given-Some-Letters…" class="headerlink" title="F. You Are Given Some Letters…"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1202/problem/F">F. You Are Given Some Letters…</a></h2><p>$\text{Solution: }$</p>
<p>不妨考虑枚举完整的循环节数 $p$,此时对应的 $k$ 的范围为 $[l,\dfrac{n}{\lfloor\dfrac{n}{l}\rfloor}]$。</p>
<p>设一个循环节 $\texttt{a}$ 的数量为 $a’$，$\texttt{b}$ 的数量为 $b’$，则有：</p>
<p>$\lfloor\dfrac{a}{p+1}\rfloor\le a’\le \lfloor\dfrac{a}{p}\rfloor - ①$</p>
<p>$\lfloor\dfrac{b}{p+1}\rfloor\le b’\le \lfloor\dfrac{b}{p}\rfloor - ②$</p>
<p>$①+②$ 得：$\lfloor\dfrac{a+b}{p+1}\rfloor\le a’+b’\le\lfloor\dfrac{a+b}{p}\rfloor$</p>
<p>而 $k&#x3D;a’+b’$，两个范围取交则得到了循环节数量为 $p$ 时 $k$ 的取值方案，计算过后，将 $l$ 设为 $\dfrac{n}{\lfloor\dfrac{n}{l}\rfloor}+1$。</p>
<p>时间复杂度 $\mathcal{O}(\sqrt{a+b})$。</p>
<h1 id="Educational-Codeforces-Round-71-text-1207"><a href="#Educational-Codeforces-Round-71-text-1207" class="headerlink" title="Educational Codeforces Round 71$\text{(1207)}$"></a>Educational Codeforces Round 71$\text{(1207)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Penalty}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
<th align="center">$\texttt{G}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$251$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+1}$</td>
<td align="center">$\texttt{+1}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+1}$</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:03}$</td>
<td align="center">$\text{00:12}$</td>
<td align="center">$\text{00:25}$</td>
<td align="center">$\text{00:44}$</td>
<td align="center">$\text{01:01}$</td>
<td align="center">$\text{01:16}$</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>比赛时间：$\text{2022&#x2F;1&#x2F;29 20:05}$</p>
<h2 id="A-There-Are-Two-Types-Of-Burgers"><a href="#A-There-Are-Two-Types-Of-Burgers" class="headerlink" title="A. There Are Two Types Of Burgers"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/A">A. There Are Two Types Of Burgers</a></h2><p>$\text{Solution:}$</p>
<p>看哪个贵就先做哪个，若还有剩余的面包就再做另一个。</p>
<h2 id="B-Square-Filling"><a href="#B-Square-Filling" class="headerlink" title="B. Square Filling"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/B">B. Square Filling</a></h2><p>$\text{Solution:}$</p>
<p>操作次数可以达到 $n^2$，故判断一下每一个小正方形是否能进行操作，最后检查操作后的矩阵是否为所求矩阵。</p>
<p>$\text{Extention:}$</p>
<p>找到一种操作次数最少的方案。</p>
<h2 id="C-Gas-Pipeline"><a href="#C-Gas-Pipeline" class="headerlink" title="C. Gas Pipeline"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/C">C. Gas Pipeline</a></h2><p>$\text{Solution:}$</p>
<p>定义 $dp_{i,1&#x2F;2}$ 表示当前进行到第 $i$ 个位置，且当前的高度为 $1&#x2F;2$ 的最小费用。</p>
<p>考虑通车和不通车的情况：</p>
<ul>
<li>通车：$dp_{i,2} &#x3D; dp_{i-1,2}+a+2b$；</li>
<li>不通车：$dp_{i,1}&#x3D;\min(dp_{i-1,1}+a+b,dp_{i-1,2}+2a+b)$,$dp_{i,2}&#x3D;\min(dp_{i-1,2}+a+2b,dp_{i-1,1}+2a+2b)$。</li>
</ul>
<p>注意第一个和最后一个的高度已被确定为 $1$，所以 $dp_{0,1}&#x3D;b,dp_{0,2}&#x3D;Inf$，最后答案为 $dp_{n,1}$。</p>
<h2 id="D-Number-Of-Permutations"><a href="#D-Number-Of-Permutations" class="headerlink" title="D. Number Of Permutations"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/D">D. Number Of Permutations</a></h2><p>$\text{Solution:}$</p>
<p>利用容斥原理，将答案转化为求总方案数减 $a$ 排好序的方案数减 $b$ 排好序的方案数加 $a,b$ 都排好序的方案数。</p>
<p>注意 $a,b$ 可能无法同时都排好序。</p>
<h2 id="E-XOR-Guessing"><a href="#E-XOR-Guessing" class="headerlink" title="E. XOR Guessing"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/E">E. XOR Guessing</a></h2><p>$\text{Solution:}$ </p>
<p>观察到这个数在二进制下不超过 $14$ 位，且每次询问 $100$ 个数。</p>
<p>故第一次询问，用 $100$ 个前 $7$ 位全部为 $1$ 的数，这样这个数前 $7$ 位就可以确定。</p>
<p>第二次询问，用 $100$ 个后 $7$ 位全部为 $1$ 的数，这样这个数的后 $7$ 为也可以确定。</p>
<p>最终将两次结果拼起来即可，因为 $2^7&#x3D;128&gt;100$，故一定能找到 $100$ 个前 $7$ 位相同或 $100$ 个后 $7$ 位相同的数。</p>
<h2 id="F-Remainder-Problem"><a href="#F-Remainder-Problem" class="headerlink" title="F. Remainder Problem"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/F">F. Remainder Problem</a></h2><p>$\text{Solution:}$</p>
<p>本题采用根号分治。</p>
<p>我们需要额外开一个数组 $sum_{i,j}$ 表示所有下标模 $i$ 余 $j$ 的数之和，但我们只需保存 $1\le i\le \sqrt{n},0\le j&lt;i$ 的情况。</p>
<ul>
<li>进行修改操作时，枚举 $1\le i \le \sqrt{n}$ 更新 $sum_{i,x\mod i}$，复杂度 $\mathcal{O}(\sqrt{n})$；</li>
<li>进行查询操作，若 $1\le x\le \sqrt{n}$，直接查 $sum$ 即可，复杂度 $\mathcal{O}(1)$，若 $x&gt;\sqrt{n}$，暴力查询即可，复杂度 $\mathcal{O}(\sqrt{n})$。</li>
</ul>
<p>总时间复杂度 $\mathcal{O}(n\sqrt{n})$，空间复杂度 $\mathcal{O}(n)$。</p>
<p><del>终于知道时限为什么给 $4$ 秒了。</del></p>
<h2 id="G-Indie-Album"><a href="#G-Indie-Album" class="headerlink" title="*G. Indie Album"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/problem/G">*G. Indie Album</a></h2><p>$\text{Solution:}$</p>
<p>一道 AC 自动机的深层运用。</p>
<p>首先对于一棵字典树，求出每个节点 $i$ 的 $fail_i$，并连一条 $fail_i \rightarrow i$ 的有向边，称新建出的树为 $fail$ 树。</p>
<p>则有，字符串 $x$  在字符串 $y$ 中出现的次数为， $fail$ 树中 $x$ 的结束节点为根的子树中 $y$ 字符串的节点的数目。</p>
<p>将询问离线，在 $i$ 字符串结尾节点打入新字符串的结尾节点，然后搜索 $Trie$ 树，每到一个节点，节点权值 $+1$，碰到查询时需要查询子树和。</p>
<p>时间复杂度 $\mathcal{O}(|T|\log|T|)$。</p>
<p>$\text{Code: }$<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1207/submission/145308976">Submission #145308976 - Codeforces</a></p>
<h1 id="Educational-Codeforces-Round-122-text-1633"><a href="#Educational-Codeforces-Round-122-text-1633" class="headerlink" title="Educational Codeforces Round 122$\text{(1633)}$"></a>Educational Codeforces Round 122$\text{(1633)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Penalty}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$55$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:02}$</td>
<td align="center">$\text{00:06}$</td>
<td align="center">$\text{00:17}$</td>
<td align="center">$\text{00:30}$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>比赛时间： $\text{2022&#x2F;1&#x2F;31 22:35}$</p>
<h2 id="A-Div-7"><a href="#A-Div-7" class="headerlink" title="A. Div. 7"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/problem/A">A. Div. 7</a></h2><p>$\text{Solution:}$</p>
<p>对于一个数 $x$，如果它能被 $7$ 整除，则不作修改直接输出，否则调整它的个位，找到一个能被 $7$ 整除的数输出。</p>
<p>因为每连续 $7$ 个数就会有一个被 $7$ 整除，所以一定会有一个数符合要求。</p>
<h2 id="B-Minority"><a href="#B-Minority" class="headerlink" title="B. Minority"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/problem/B">B. Minority</a></h2><p>$\text{Solution:}$</p>
<p>不难想到将整个字符串全部选中的贡献。</p>
<p>若 $\texttt{0}$ 和 $\texttt{1}$ 的数量相等，我们只要去掉开头或结尾就取得最优答案；</p>
<p>若 $\texttt{0}$ 和 $\texttt{1}$ 的数量不等，我们全选就可以做到最优答案。</p>
<p>可以证明其它的选择一定不优于这么选择。</p>
<h2 id="C-Kill-the-Monster"><a href="#C-Kill-the-Monster" class="headerlink" title="C. Kill the Monster"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/problem/C">C. Kill the Monster</a></h2><p>$\text{Solution:}$</p>
<p>硬币的数量很少，考虑枚举用来加血的硬币的数量，然后只需判断谁能赢即可。</p>
<p>时间复杂度 $\mathcal{O}(\sum k)$。</p>
<p>$\text{Extention:}$</p>
<p>$\sum k \le 10^9$</p>
<h2 id="D-Make-Them-Equal"><a href="#D-Make-Them-Equal" class="headerlink" title="D. Make Them Equal"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/problem/D">D. Make Them Equal</a></h2><p>$\text{Solution:}$</p>
<p>一个最直接的想法：对于一个值 $x$，求出从 $1$ 操作到 $x$ 的最小次数 $v_x$，然后问题就变成了你有容量为 $k$ 的背包，和 $n$ 个体积 $v_i$，价值 $c_i$ 的物品，求最大的价值。</p>
<p>这不就是一个0-1背包的事。</p>
<p>但看了看范围 $n\le10^3,k\le10^6$，0-1背包复杂度是 $\mathcal{O}(nk)$，不可过啊。</p>
<p>但当你求出 $v$ 后发现：最大的 $v_x$ 竟然不超过 $12$，也就是操作数最多不会超过 $12n$。</p>
<p>那么我们可以先求一个 $sumv$，然后与 $k$ 取 $\min$，复杂度就降到了 $\mathcal{O}(12n^2)$。</p>
<p>$\text{Code: }$<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/submission/144900381">Submission #144900381 - Codeforces</a></p>
<h2 id="E-Spanning-Tree-Queries"><a href="#E-Spanning-Tree-Queries" class="headerlink" title="E. Spanning Tree Queries"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/problem/E">E. Spanning Tree Queries</a></h2><p>$\text{Solution:}$</p>
<p>暴力做法是：对于一个询问，把边权都跑出来，然后做一次最小生成树，时间复杂度 $\mathcal{O}(qm\log m)$。</p>
<p>但细想之后，发现我们并不用对于每一次询问都跑一次最小生成树，如果边的大小关系没有因为这次询问而变化，那么选出的最小生成树边集还会由上一次的边集组成。</p>
<p>那么我们如何得知边的大小关系发生了改变呢？</p>
<p>比如，对于两条边 $x$ 和 $y$，它们的边权为 $w_x$ 和 $w_y$ 且 $w_x&lt;w_y$，设当前询问的值为 $v$。</p>
<ul>
<li><p>当 $v&lt; w_x$ 时，$w_x-v&lt;w_y-v$；</p>
</li>
<li><p>当 $w_x\le v&lt; \lfloor \dfrac{w_x+w_y}{2} \rfloor+1$ 时，$v-w_x \le w_y-v$；</p>
</li>
<li><p>当 $\lfloor \dfrac{w_x+w_y}{2}\rfloor +1\le v&lt; w_y$ 时，$v-w_x&gt;w_y-v$；</p>
</li>
<li><p>当 $v\ge w_y$ 时， $v-w_x&lt;v-w_y$。</p>
<p>所以可得，对于每两条边，共有 $4$ 种情况，所以总共的情况也只有 $m^2$ 量级，可以接受。</p>
<p>那么我们只需将原边权与 $\lfloor \dfrac{w_x+w_y}{2}\rfloor+1$ 放入一个数组并排序，再将所有询问排序。</p>
<p>当询问的值又超过了一条新边的边权，代表有边的大小关系改变，我们需要重求一遍最小生成树；若这一次询问的并没有使边的大小关系发生改变，我们仍然可以用上一次最小生成树的结果，再加上这次询问对绝对值的贡献。</p>
<p>时间复杂度 $\mathcal{O}(q\log q+m^3\log m)$。</p>
<p>但如果把优先预处理出所有最小生成树的情况，询问的时候二分出对应的情况，复杂度会变为 $\mathcal{O}(q\log m^2+m^3\log m)$，稍有优化。</p>
<p>$\text{Code: }$<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/submission/144900383">Submission #144900383 - Codeforces</a></p>
</li>
</ul>
<h2 id="F-Perfect-Matching"><a href="#F-Perfect-Matching" class="headerlink" title="*F. Perfect Matching"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/problem/F">*F. Perfect Matching</a></h2><p>$\text{Solution:}$</p>
<p>依题意，分析满足完美匹配的条件。</p>
<p>我们有一种贪心的策略来检查是否可以完美匹配：定义一次匹配操作为选择当前最深的激活节点，与它的父亲之间连边，并删去这两个点，重复一次匹配操作，直到激活节点全部被清空即为完美匹配。时间复杂度 $\mathcal{O}(n)$。</p>
<p>观察到 $1$ 操作次数很多，而真正要求输出方案的 $2$ 操作数目很少，考虑能否快速有效地判断当前情形是否能完美匹配。</p>
<p>因为每次激活的节点必须与之前激活的节点连通，那么每次激活都会仅有一个包含全部激活节点的连通块，且连通块也是树，暂时称为激活树，考虑激活树有什么条件才能满足完美匹配。</p>
<p>我们先令一个节点，它的子树（包括自己）的总共的激活节点的数目为奇数，称之为奇数节点，反之称为偶数节点。</p>
<p>如果这棵激活树能够完美匹配，对于每一次匹配操作，取出的子节点和父节点当且仅当子节点是父节点唯一的儿子。</p>
<p>若此子节点不是父节点唯一的儿子，由匹配操作定义，树的结构如图所示：</p>
<img src="https://s2.loli.net/2022/02/02/BjsxLPJhRmHlCYi.png" alt="CF1633F-1.png" style="zoom:50%;" />

<p>删除 $u$ 和 $v_1$ 后，$v_2$ 与 $v_3$ 必然无法形成完美匹配，与假设矛盾。</p>
<p>那么每一次匹配，一定是一个奇数节点和一个偶数节点，且在删除后，其它节点的子树（包括自己）的总共的激活结点数目要么减 $2$，要么无变化。则其余的奇偶节点仍无变化。</p>
<p>故可推出一个重要结论：若激活树能完美匹配当且仅当奇数节点数目等于偶数节点数目。</p>
<p>那么现在问题就转化为了：</p>
<ul>
<li>添加一个点，翻转它的父亲到 $1$ 节点这条路径上所有节点的状态；</li>
<li>查询一个点到 $1$ 节点这条路径上奇数节点的数目。</li>
</ul>
<p>用树剖解决即可。</p>
<p>在进行 $2$ 操作时，只需 $dfs$ 一遍，求子树 $sz$，判断这个点是否为奇数节点，如果是就将此节点和其父亲连接。</p>
<p>时间复杂度 $\mathcal{O}(n\log^2 n)$。</p>
<p>$\text{Code: }$<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1633/submission/144900385">Submission #144900385 - Codeforces</a></p>
<h1 id="CodeTON-Round-1-text-1656"><a href="#CodeTON-Round-1-text-1656" class="headerlink" title="CodeTON Round 1$\text{(1656)}$"></a>CodeTON Round 1$\text{(1656)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Score}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
<th align="center">$\texttt{G}$</th>
<th align="center">$\texttt{H}$</th>
<th align="center">$\texttt{I}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$6098$</td>
<td align="center">$\texttt{496}$</td>
<td align="center">$\texttt{976}$</td>
<td align="center">$\texttt{1404}$</td>
<td align="center">$\texttt{1696}$</td>
<td align="center">$\texttt{1530}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:04}$</td>
<td align="center">$\text{00:10}$</td>
<td align="center">$\text{00:16}$</td>
<td align="center">$\text{00:38}$</td>
<td align="center">$\text{01:37}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">.</td>
</tr>
</tbody></table>
<p>比赛时间： $\text{2022&#x2F;7&#x2F;28 08:30}$</p>
<p>为即将到来的 CodeTON Round 2 练习一下。</p>
<h2 id="A-Good-Pairs"><a href="#A-Good-Pairs" class="headerlink" title="A. Good Pairs"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/problem/A">A. Good Pairs</a></h2><p>$\text{Solution:}$</p>
<p>考虑 $|a_i-a_k|+|a_k-a_j|&#x3D;|a_i-a_j|$ 什么时候成立，即找到 $a_i\le a_k\le a_j$ 的三元组，由于题目保证有解，所以取最小值和最大值就行。</p>
<h2 id="B-Subtract-Operation"><a href="#B-Subtract-Operation" class="headerlink" title="B. Subtract Operation"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/problem/B">B. Subtract Operation</a></h2><p>$\text{Solution:}$</p>
<p>考虑 $n$ 个数为 $a_1,a_2\cdots,a_n$。第一次我们消去 $a_p$，则序列变为 $a_1-a_p,a_2-a_p,\cdots,a_n-a_p$。</p>
<p>再次消掉 $a_q$，则原序列变为 $(a_1-a_p)-(a_q-a_p),(a_2-a_p)-(a_q-a_p),\cdots,(a_n-a_p)-(a_q-a_p)$ 也就是 $a_1-a_q,a_2-a_q,\cdots,a_n-a_q$，这样我们可以发现，在第 $1\sim (n-2)$ 次选择的数全部被抵消，最后剩下一个 $a_x-a_y$ 的形式，直接用 map 维护一下有没有相差为 $k$ 的数。</p>
<h2 id="C-Make-Equal-With-Mod"><a href="#C-Make-Equal-With-Mod" class="headerlink" title="C. Make Equal With Mod"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/problem/C">C. Make Equal With Mod</a></h2><p>$\text{Solution:}$</p>
<p>如果序列中没有 $1$，从最大数开始，一个一个模成 $0$，没有任何问题。</p>
<p>如果序列中存在 $1$，那么就需要将所有数都变成 $1$，对于最大数，我们要模最大数减 $1$，所以我们要判断是否有大小相差为 $1$ 的数，如果没有，即能满足要求。</p>
<h2 id="D-K-good"><a href="#D-K-good" class="headerlink" title="D. K-good"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/problem/D">D. K-good</a></h2><p>$\text{Solution:}$</p>
<p>如果 $n$ 是 $k$-good 数，当且仅当：</p>
<p>$n&#x3D;pk+\dfrac{k(k-1)}{2},p\in \mathbb{N}$</p>
<p>考虑进一步转化：</p>
<p>$\Rightarrow 2n&#x3D;2pk+k(k-1)$</p>
<p>$\Rightarrow 2n&#x3D;k(2p+k-1)$</p>
<p>考虑 $k$ 和 $2p+k-1$ 的奇偶性不同，则一定是 $2$ 的正整数次幂和一个奇数相乘的组合，又因为 $k&lt;2p+k-1$，取 $k&#x3D;\min(2^m,\dfrac{2n}{2^m})$，如果 $k&#x3D;1$ 则输出 $-1$。</p>
<h2 id="E-Equal-Tree-Sums"><a href="#E-Equal-Tree-Sums" class="headerlink" title="E. Equal Tree Sums"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/problem/E">E. Equal Tree Sums</a></h2><p>$\text{Solution:}$</p>
<p>记 $u$ 的子节点个数为 $k$，分别为 $v_1,v_2,\cdots,v_k$，$sum_u$ 表示以 $u$ 为根的子树权值和，以 $1$ 为根节点时，以 $u$ 为划分点，有如下的式子：</p>
<p>$sum_{v_1}&#x3D;sum_{v_2}&#x3D;\cdots&#x3D;sum_{v_k}&#x3D;sum_1-sum_u$</p>
<p>$sum_u&#x3D;a_u+\sum\limits_{i&#x3D;1}^{k}sum_{v_i}$</p>
<p>则 $a_u&#x3D;sum_u-\sum\limits_{i&#x3D;1}^ksum_{v_i}$</p>
<p>$&#x3D;sum_u-k(sum_1-sum_u)$</p>
<p>$&#x3D;(k+1)sum_u-ksum_1$</p>
<p>我们不妨假设树的总权值和为 $0$，那么就有：</p>
<p>$a_u&#x3D;(k+1)sum_u$</p>
<p>$sum_{v_1}&#x3D;sum_{v_2}&#x3D;\cdots&#x3D;sum_{v_k}&#x3D;-sum_u$</p>
<p>这样 $sum_u&#x3D;(k+1)sum_u-ksum_u&#x3D;sum_u$，刚好满足。</p>
<p>具体实现的话，可以使 $sum_u&#x3D;(-1)^{dep_u}$，$sum_1&#x3D;0$，就能构造出合法权值。</p>
<h2 id="F-Parametric-MST"><a href="#F-Parametric-MST" class="headerlink" title="F. Parametric MST"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/problem/F">F. Parametric MST</a></h2><p>$\text{Solution:}$</p>
<p>不妨先将 $a$ 按升序排序，考虑设 $b_u(t)&#x3D;a_u+t$。</p>
<p>那么 $w_{i,j}(t)&#x3D;(a_i+t)(a_j+t)-t^2&#x3D;b_i(t)b_j(t)-t^2$，也就是当 $i,t$ 一定时，$w_{i,j}(t)$ 有最小值：</p>
<ul>
<li>当 $b_i(t)&lt;0$ 时，取 $b(t)$ 的最大值，即 $j&#x3D;n$；</li>
<li>当 $b_i(t)&gt;0$ 时，取 $b(t)$ 的最小值，即 $j&#x3D;1$。</li>
</ul>
<p>那么我们对于一个 $t$，就有如下的连边方式：</p>
<ol>
<li>如果 $b_i(t)&lt;0,i\neq n$，$i$ 向 $n$ 连边。</li>
<li>如果 $b_i(t)&gt;0,i\neq 1$，$i$ 向 $1$ 连边。</li>
<li>如果 $(1,n)$ 间重边，删去一条。</li>
</ol>
<p>这样连边构成了一棵树，且是 $K_n(t)$ 的最小生成树。</p>
<p>我们不妨考虑当 $t$ 取 $(-\infty,-a_n)$ 与 $(-a_1,+\infty)$ 时的函数。</p>
<p>当 $t\in (-\infty,-a_n]$ 时，$b_1(t)\le b_2(t)\le \cdots\le b_n(t)&lt; 0$，那么最小生成树为 $1\sim n-1$ 向 $n$ 连边。</p>
<p>$K_n(t)&#x3D;a_n(sum-a_n)+t\cdot((n-1)a_n+(sum-a_1))$</p>
<p>$&#x3D;((n-2)a_n+sum)t+a_n(sum-a_n)$</p>
<p>这是一个一次函数的形式，当斜率 $(n-2)a_n+sum&lt;0$ 时， $\lim\limits_{t\to -\infty}K_n(t)&#x3D;+\infty$，无最大值。</p>
<p>当 $t\in[-a_1,+\infty]$ 时，同理，得斜率 $(n-2)a_1+sum&gt;0$ 时，无最大值。</p>
<p>接下来考虑 $[-a_n,-a_1]$ 的情况。</p>
<p>一个结论是 $t$ 需要取在 $-a_i$ 上，若在两个相反数之间，因为一段之间是一次函数，必定在端点上取最小值。</p>
<p>那么我们考虑 $t$ 从 $-a_1$ 开始 $-a_i\rightarrow -a_{i+1}$，函数的变化。</p>
<p>考虑 $K_n(-a_1)&#x3D;((n-2)a_1+sum)(-a_1)+a_1(sum-a_1)$</p>
<p>由于整个函数是连续的，则 $K_n(-a_2)&#x3D;((n-2)a_1+sum)(-a_2)+a_1(sum-a_1)$，即斜率暂时不变。</p>
<p>那么函数变化为：$-((n-2)a_1+sum)a_1\rightarrow-((n-2)a_1+sum)a_2$，即当前斜率 $k*(-a_2-(-a_1))$。</p>
<p>当转成新一部分的斜率时，斜率从 $((n-2)a_1+sum)$ 变为 $((n-2)a_1+(sum-a_1-a_2)+a_n-a_2)&#x3D;((n-3)a_1+sum+a_n)$，改变为 $-a_1+a_n$。</p>
<p>这样我们就解决了这道题。</p>
<p>时间复杂度上界为排序的 $\mathcal{O}(n\log n)$。</p>
<p>$\text{Code: }$	<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1656/submission/165986233">Submission #165986233 - Codeforces</a></p>
<h1 id="Codeforces-Global-Round-21-text-1696"><a href="#Codeforces-Global-Round-21-text-1696" class="headerlink" title="Codeforces Global Round 21$\text{(1696)}$"></a>Codeforces Global Round 21$\text{(1696)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Score}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
<th align="center">$\texttt{G}$</th>
<th align="center">$\texttt{H}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$4040$</td>
<td align="center">$\texttt{492}$</td>
<td align="center">$\texttt{964}$</td>
<td align="center">$\texttt{1216}$</td>
<td align="center">$\texttt{1368}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:04}$</td>
<td align="center">$\text{00:09}$</td>
<td align="center">$\text{00:39}$</td>
<td align="center">$\text{01:19}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">.</td>
</tr>
</tbody></table>
<p>比赛时间：$\text{2022&#x2F;7&#x2F;30 08:30}$</p>
<h2 id="A-NIT-orz"><a href="#A-NIT-orz" class="headerlink" title="A. NIT orz!"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1696/problem/A">A. NIT orz!</a></h2><p>$\text{Solution:}$</p>
<p>因为 $z$ 只能被进行<strong>与</strong>操作，也就是 $z$ 在二进制下 $1$ 的个数越来越少，所以我们不如用最开始的 $z$ 去和 $a$ 中的数进行<strong>或</strong>操作求得最大值。</p>
<h2 id="B-NIT-Destroys-the-Universe"><a href="#B-NIT-Destroys-the-Universe" class="headerlink" title="B. NIT Destroys the Universe"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1696/problem/B">B. NIT Destroys the Universe</a></h2><p>$\text{Solution:}$</p>
<p>首先，进行两次 $l&#x3D;1,r&#x3D;n$ 的操作就能使 $a_i&#x3D;0$，所以答案上限是 $2$。</p>
<p>如果序列中只有 $1$ 段连续的不为 $0$ 的数，那么答案为 $1$，如果全 $0$ 答案是 $0$。</p>
<h2 id="C-Fishingprince-Plays-With-Array"><a href="#C-Fishingprince-Plays-With-Array" class="headerlink" title="C. Fishingprince Plays With Array"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1696/problem/C">C. Fishingprince Plays With Array</a></h2><p>$\text{Solution:}$</p>
<p>考虑两种操作是<strong>互逆的</strong>，也就是如果我们把某个数分开，可以随时合回来。</p>
<p>那么可以先将 $a$ 序列和 $b$ 序列能拆分的全部拆分，即 $qa_i$ 和 $ta_i$ 表示 $a_i$ 能拆成的最小数和拆出的个数，$qb_i$ 和 $tb_i$ 表示 $b_i$ 能拆成的最小数和拆出的个数。</p>
<p>考虑只有一段连续相同 $qa$ 和 $qb$ 才能合并，计算 $\sum ta$，判断 $qb$ 是否等于 $qa$ 且 $\sum tb$ 是否等于 $\sum ta$，不断用指针向前移动，最后两串全部匹配成功就输出 <code>Yes</code>。</p>
<h2 id="D-Permutation-Graph"><a href="#D-Permutation-Graph" class="headerlink" title="D. Permutation Graph"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1696/problem/D">D. Permutation Graph</a></h2><p>$\text{Solution:}$</p>
<p>我们先得到整个数组 $a$ 的最大值编号为 $id$，不难发现 $[1,id-1]$ 无法向 $[id+1,n]$ 连边，那么我们就必须先想办法从 $[1,id-1]$ 跳到 $id$ 再去跳到 $[id+1,n]$。</p>
<p>接下来去考虑 $[1,id-1]$ 中的最小值为 $p$。首先 $[1,p-1]$ 肯定可以走到 $p$，而 $p$ 肯定能跳到 $id$，所以我们就不必去管 $[p+1,id-1]$，因为答案不优。这样我们就递归到了一个更小的区间。</p>
<p>$[id+1,n]$ 的考虑也是同理，找到最小值后，但这次我们只需求靠右的区间即可。</p>
<p>本题中需要注意两个点：</p>
<ul>
<li>如果当前求的区间最大值，接下来递归时就有改求区间最小值，然后再次递归再求区间最大值，即每次最大最小转换。</li>
<li>如果当前求的最小值就在 $1$ 或 $n$，则可以省去这一步。</li>
</ul>
<p>具体维护上，带一个 log 也可以，复杂度 $\mathcal{O}(n\log n)$。</p>
<h2 id="E-Placing-Jinas"><a href="#E-Placing-Jinas" class="headerlink" title="E. Placing Jinas"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1696/problem/E">E. Placing Jinas</a></h2><p>$\text{Solution:}$</p>
<p>首先，不难发现，本题并不是最优解问题，因为移动的步数确定，我们只要考虑移动需要多少步。</p>
<p>我们考虑 $f(x,y)$ 为点 $(x,y)$ 的操作次数，那么答案为 $\sum\limits_{i&#x3D;0}^n\sum\limits_{j&#x3D;0}^{a_i}f(i,j)$。</p>
<p>不难发现 $f(x,0)&#x3D;1,f(0,y)&#x3D;1,f(x,y)&#x3D;f(x-1,y)+f(x,y-1)$。即 $f(x,y)&#x3D;{x+y\choose x}$ 。（斜着的杨辉三角）</p>
<p>算到这是 $O(n^2)$ 的，但是推过结论的应该已经都会了，这里再来推一下：</p>
<p>考虑第 $i$ 行的贡献：</p>
<p>$\sum\limits_{j&#x3D;0}^{a_i-1}f(i,j)&#x3D;\sum\limits_{j&#x3D;0}^{a_i-1}{i+j\choose i}&#x3D;\sum\limits_{j&#x3D;0}^{a_i-1}\dfrac{A_{i+j}^i}{A_i^i}&#x3D;\dfrac{\sum\limits_{j&#x3D;0}^{a_i-1} A_{i+j}^i}{A_i^i}$</p>
<p>而 $\sum\limits_{j&#x3D;0}^{a_i-1} A_{i+j}^i$ 是整数裂项的形式，化简后为 $\dfrac{\prod\limits_{j&#x3D;a_i-1}^{a_i+i}j}{i+1}&#x3D;\dfrac{A_{a_i+i}^{a_i+i}}{(i+1)A_{a_i-1}^{a_i-1}}$</p>
<p>最终 $\sum\limits_{j&#x3D;0}^{a_i}f(i,j)&#x3D;\dfrac{A_{a_i+i}^{a_i+i}}{(i+1)A_{a_i-1}^{a_i-1}A_i^i}&#x3D;\dfrac{A_{a_i+i}^{a_i+i}}{A_{a_i-1}^{a_i-1}A_{i+1}^{i+1}}&#x3D;{a_i+i\choose a_i-1}$。</p>
<p>于是预处理阶乘和逆元，复杂度为 $\mathcal{O}(n)$。</p>
<h1 id="CodeTON-Round-2-text-1704"><a href="#CodeTON-Round-2-text-1704" class="headerlink" title="CodeTON Round 2$\text{(1704)}$"></a>CodeTON Round 2$\text{(1704)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Score}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
<th align="center">$\texttt{G}$</th>
<th align="center">$\texttt{H1}$</th>
<th align="center">$\texttt{H2}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$3406$</td>
<td align="center">$\texttt{489}$</td>
<td align="center">$\texttt{719}$</td>
<td align="center">$\texttt{1130}$</td>
<td align="center">$\texttt{1068}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:07}$</td>
<td align="center">$\text{00:13}$</td>
<td align="center">$\text{00:30}$</td>
<td align="center">$\text{01:44}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">.</td>
</tr>
</tbody></table>
<p>比赛时间：$\text{2022&#x2F;7&#x2F;31 22:05}$</p>
<p>打的仍然没有达到我的预期。</p>
<p>$\texttt{AB}$ 做的较慢，但靠 $\texttt{C}$ 挽救了回来，而 $\texttt{D}$ 挂了两发还是很晚才过，况且写法复杂，结论靠猜，算是实力缺陷的体现。</p>
<p>不过说实话，以现在的水平，真的无法快速想到 $\texttt{D}$ 的性质，希望能有四十分钟开出前 $4$ 题的时候吧。</p>
<h2 id="A-Two-0-1-Sequences"><a href="#A-Two-0-1-Sequences" class="headerlink" title="A. Two 0-1 Sequences"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/A">A. Two 0-1 Sequences</a></h2><p>$\text{Solution:}$</p>
<p>每次操作只能改 $a$ 串的前两位，所以 $a$ 的后 $m-1$ 位不能动，这样只需匹配 $a$ 和 $b$ 的后 $m-1$ 位，再看 $a$ 的 $1\sim n-m+1$ 位有没有 $b_1$。</p>
<h2 id="B-Luke-is-a-Foodie"><a href="#B-Luke-is-a-Foodie" class="headerlink" title="B. Luke is a Foodie"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/B">B. Luke is a Foodie</a></h2><p>$\text{Solution:}$</p>
<p>考虑如果一段连续的区间的最大值和最小值相差超过 $2x$，那么一定需要更换。那么我们只需模拟一下，看看哪些地方需要更换即可。</p>
<h2 id="C-Virus"><a href="#C-Virus" class="headerlink" title="C. Virus"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/C">C. Virus</a></h2><p>$\text{Solution:}$</p>
<p>用最开始被感染的房屋将所有房子划分为若干个小段，我们可以用两天把一段区间的边界给保护，这样中间全都不用保护，现在考虑进行这个操作的顺序。</p>
<p>不难想到应该从大区间往小区间封闭，因为每天每段区间会有两个房子被感染，而如果一段区间被感染完就不会再被感染，所以先去保护大区间，小区间可能在中途被感染完，损耗的房屋更少。</p>
<h2 id="D-Magical-Array"><a href="#D-Magical-Array" class="headerlink" title="D. Magical Array"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/D">D. Magical Array</a></h2><p>$\text{Solution:}$</p>
<p>考场上想的做法是将 $c$ 数组用反操作处理，选择最靠两段的数，把它往中间移动，最后合并的不能合为止。然后发现有 $m-1$ 个序列是一样的，找到特殊序列后，通过观察样例发现 $2$ 操作次数，就是合并后特殊序列进行多少次单独的移动得到非特殊序列，然后就通过了，做法猜的东西很多。</p>
<p>题解是这样的：</p>
<p>设每一位的权值为 $a_i\times i$。则非特殊序列的其中四个位置 $(i,i+1,j-1,j)$ 的权值为 $a_i\times i+a_{i+1}\times(i+1)+a_{j-1}\times(j-1)+a_j\times j$，进行 $(i+1,j-1)$ 操作 $1$ 后，仍然考虑这 $4$ 个位置的权值和，其它位置的权值不变。</p>
<p>$(a_i+1)\times i+(a_{i+1}-1)\times(i+1)+(a_{j-1}-1)\times(j-1)+(a_j+1)\times j$</p>
<p>$&#x3D;a_i\times i+a_{i+1}\times(i+1)+a_{j-1}\times(j-1)+a_j\times j+i-(i+1)-(j-1)+j$</p>
<p>$&#x3D;a_i\times i+a_{i+1}\times(i+1)+a_{j-1}\times(j-1)+a_j\times j$</p>
<p>所以在操作后总权值不变，这样求出 $\sum a_i\times i$ 就能找出特殊数组。</p>
<p>考虑进行一次操作 $2$ 权值的变化情况，考虑 $(i,i+1,j-2,j)$。</p>
<p>$(a_i+1)\times i+(a_{i+1}-1)\times(i+1)+(a_{j-2}-1)\times(j-2)+(a_j+1)\times j$</p>
<p>$&#x3D;a_i\times i+a_{i+1}\times(i+1)+a_{j-2}\times(j-2)+a_j\times j+i-(i+1)-(j-2)+j$</p>
<p>$&#x3D;a_i\times i+a_{i+1}\times(i+1)+a_{j-2}\times(j-2)+a_j\times j+1$</p>
<p>每次 $2$ 操作后，数组的总权值和加 $1$，这样我们用非特殊序列的权值和减特殊序列的权值和，即能得到 $2$ 操作次数。</p>
<p>这个方法完美的避开了具体的构造方案，对序列定义一个权值，使操作有了固定的性质，成为了一个充要条件。</p>
<p>时间复杂度 $\mathcal{O}(n)$。</p>
<h2 id="E-Count-Seconds"><a href="#E-Count-Seconds" class="headerlink" title="E. Count Seconds"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/E">E. Count Seconds</a></h2><p>$\text{Solution:}$</p>
<p>首先<strong>只有一个点没有出边</strong>，称其为汇点。</p>
<p>我们考虑先模拟前 $n$ 轮，目的是如果经过 $n$ 轮后，$a_u$ 仍然有值，那么 $u$ 到汇点整条上路径的点值都会大于 $0$，保证每个不为 $0$ 的位置能直接贡献到汇点。</p>
<p>然后还剩下的每一点权值都能多撑一个单位的时间，跑个拓扑排序计算总和即可，别忘了加上开始模拟的时间。</p>
<p>如果模拟不到 $n$ 轮就结束了，记得特判。</p>
<p>时间复杂度 $\mathcal{O}(n^2)$。</p>
<h2 id="F-Colouring-Game"><a href="#F-Colouring-Game" class="headerlink" title="F. Colouring Game"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/F">F. Colouring Game</a></h2><p>$\text{Solution:}$</p>
<p>一次操作最少可改变自己的 $1$ 个字符，如果 $\texttt{R}$ 和 $\texttt{B}$ 的个数不同，那么一定个数多的赢。</p>
<p>当 $\texttt{R}$ 和 $\texttt{B}$ 的个数相同时，记一段 $\texttt{RBRB}\cdots$  的长度为 $l$。那么每次每个人都会选择一段 $\texttt{RB}$ 或 $\texttt{BR}$ 消掉，两人可以同时操作且操作后局面相同，是公平博弈论，可以求 $SG$ 函数。</p>
<p>$SG_l&#x3D;\text{mex}(SG_{i-1}\oplus SG_{l-i-1})$</p>
<p>求出 $SG$ 后发现，当 $l\ge 69$ 时，有长度为 $34$ 的循环节，所以只用打表前 $34\times3&#x3D;102$ 位 $SG$ 就足够。</p>
<h1 id="Codeforces-Round-808-text-1707"><a href="#Codeforces-Round-808-text-1707" class="headerlink" title="Codeforces Round #808$\text{(1707)}$"></a>Codeforces Round #808$\text{(1707)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Score}$</th>
<th align="center">$\texttt{2A}$</th>
<th align="center">$\texttt{2B}$</th>
<th align="center">$\texttt{2C&#x2F;1A}$</th>
<th align="center">$\texttt{2D&#x2F;1B}$</th>
<th align="center">$\texttt{2E&#x2F;1C}$</th>
<th align="center">$\texttt{2F&#x2F;1D}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$1452$</td>
<td align="center">$\texttt{492}$</td>
<td align="center">$\texttt{960}$</td>
<td align="center">$\texttt{-3}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:04}$</td>
<td align="center">$\text{00:10}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">.</td>
</tr>
</tbody></table>
<p>比赛时间：$\text{2022&#x2F;7&#x2F;16 22:35}$</p>
<h2 id="2A-Difference-Operations"><a href="#2A-Difference-Operations" class="headerlink" title="2A. Difference Operations"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/problem/A">2A. Difference Operations</a></h2><p>$\text{Solution:}$</p>
<p>不妨从 $a_2$ 开始考虑，因为 $a_2$ 进行的操作只有减去 $a_1$，所以 $a_2$ 必须是 $a_1$ 的倍数，然后我们就可以将 $a_2$ 减去若干个 $a_1$ 后变成 $a_1$。</p>
<p>考虑 $a_3$ 及以后的数也是如此，所以序列满足条件当且仅当 $a_i$ 都是 $a_1$ 的倍数，其中 $2\le i\le n$。</p>
<h2 id="2B-Difference-of-GCDs"><a href="#2B-Difference-of-GCDs" class="headerlink" title="2B. Difference of GCDs"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/problem/B">2B. Difference of GCDs</a></h2><p>$\text{Solution:}$</p>
<p>显然 $\gcd(i,a_i) \le \min(i,a_i)\le i$，又因为题目要求 $\forall 1\le i\le n$，$\gcd(i, a_i)$ 互不相等，所以 $\gcd(i,a_i)&#x3D;i$。</p>
<p>那么只需在 $l\sim r$ 看有没有 $i$ 的倍数即可，否则输出 <code>-1</code>。</p>
<h2 id="2C-x2F-1A-Doremy’s-IQ"><a href="#2C-x2F-1A-Doremy’s-IQ" class="headerlink" title="2C&#x2F;1A. Doremy’s IQ"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1707/problem/A">2C&#x2F;1A. Doremy’s IQ</a></h2><p>$\text{Solution:}$</p>
<p>场上被骗的一道题目，如果正向考虑，肯定是希望做减智商的测试越晚越好，但不容易实现。</p>
<p>那就反向考虑，设初始智商为 $0$，倒向做测试，遇到做不动的智商 $+1$，智商最多加到 $q$，这样如果我们遇到一个做不动的测试，但智商还没加到 $q$，那么我们一定要去做，因为智商越高，后面更有可能完成更多测试。</p>
<p>时间复杂度 $\mathcal{O}(n)$。</p>
<h2 id="2D-x2F-1B-Difference-Array"><a href="#2D-x2F-1B-Difference-Array" class="headerlink" title="2D&#x2F;1B. Difference Array"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1707/problem/B">2D&#x2F;1B. Difference Array</a></h2><p>$\text{Solution:}$</p>
<p>不妨来证明暴力做法复杂度的正确性。</p>
<p>我们设每次操作后并忽略 $0$ 的 $a$ 数组总和为 $S$，$S&#x3D;\sum\limits_{i&#x3D;1}^ma_i$，且根据题意有 $\forall1&lt;i\le m$，$a_{i+1}-a_{i}&gt;0$。</p>
<p>$S&#x3D;\sum\limits_{i&#x3D;1}^ma_i\ge m-1+a_m$</p>
<p>那么差分一次后的数组变为 $a_2-a_1,a_3-a_2,\cdots,a_m-a_{m-1}$，现在的总和 $S’&#x3D;a_m-a_1\le a_m$。</p>
<p>原本大于等于 $a_m+m-1$，现在小于等于 $a_m$，说明每次至少减少了 $m-1$，在第一次差分后，数组总和不超过 $a_n$，那么最坏情况的复杂度就为 $\mathcal{O}(A\log A)$，其中 $A&#x3D;\max(n,a_n)$。</p>
<h2 id="2E-x2F-1C-DFS-Trees"><a href="#2E-x2F-1C-DFS-Trees" class="headerlink" title="2E&#x2F;1C. DFS Trees"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1707/problem/C">2E&#x2F;1C. DFS Trees</a></h2><p>$\text{Solution:}$</p>
<p>这题有个结论：如果 $\text{findMST(u)}$ 得到的生成树为最小生成树，那么图中没有交叉边。</p>
<p>关于交叉边的定义，我们可以用一个例子理解。</p>
<img src="https://s2.loli.net/2022/07/18/doOfyY3MSw2NZqb.jpg" alt="CF1707C-1.jpg" style="zoom:50%;" />

<p>白边为生成树边，则红边为交叉边，而蓝边不是交叉边，即交叉边的最近公共祖先不为边的端点。</p>
<p>至于上面的结论为什么成立，现在还不太知道，先硬记一下吧。</p>
<p>那么对于每条非树边，如果能作为以 $u$ 为根的生成树的交叉边，那么 $\text{findMST(u)}$ 就得不到最小生成树。</p>
<p>我们以 $1$ 为根节点，跑出最小生成树，对于一条非树边 $(u,v)$：</p>
<ul>
<li>$lca&#x3D;u$ 或 $lca&#x3D;v$，那么以 $u,v$ 这条路径中间的点（不包括 $u,v$）为根，$(u,v)$ 就会作为一条交叉边，这些点都得不到最小生成树。</li>
<li>否则，那么从 $1$ 到 $u$ 的父节点和 $1$ 到 $v$ 的父节点的路径就全部得不到最小生成树。</li>
</ul>
<p>最后统计答案即可，维护方法有很多，时间复杂度 $\mathcal{O}(n\log n)$。</p>
<h1 id="Codeforces-Round-809-Div-2-text-1706"><a href="#Codeforces-Round-809-Div-2-text-1706" class="headerlink" title="Codeforces Round #809 (Div. 2)$\text{(1706)}$"></a>Codeforces Round #809 (Div. 2)$\text{(1706)}$</h1><table>
<thead>
<tr>
<th align="center">$\text{Score}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D1}$</th>
<th align="center">$\texttt{D2}$</th>
<th align="center">$\texttt{E}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$2214$</td>
<td align="center">$\texttt{494}$</td>
<td align="center">$\texttt{920}$</td>
<td align="center">$\texttt{800}$</td>
<td align="center">$\texttt{-1}$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:03}$</td>
<td align="center">$\text{00:20}$</td>
<td align="center">$\text{01:00}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>比赛时间：$\text{2022&#x2F;7&#x2F;18 22:35}$</p>
<p>这打的是什么垃圾，策略有误而且能力还有欠缺。</p>
<h2 id="A-Another-String-Minimization-Problem"><a href="#A-Another-String-Minimization-Problem" class="headerlink" title="A. Another String Minimization Problem"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/A">A. Another String Minimization Problem</a></h2><p>$\text{Solution:}$</p>
<p>按题意模拟，注意要先改靠前的位置。</p>
<h2 id="B-Making-Towers"><a href="#B-Making-Towers" class="headerlink" title="B. Making Towers"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/B">B. Making Towers</a></h2><p>$\text{Solution:}$</p>
<p>考虑一个相同颜色的塔，由于必须得连着，只能先往右&#x2F;左走几次，到下一行后再往左&#x2F;有走几次，也就是说只有每两个之间相距偶数个才能放在同一列上。</p>
<p>随便写写就过了。</p>
<h2 id="C-Qpwoeirut-And-The-City"><a href="#C-Qpwoeirut-And-The-City" class="headerlink" title="C. Qpwoeirut And The City"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/C">C. Qpwoeirut And The City</a></h2><p>$\text{Solution:}$</p>
<p>这题开始以为需要 dp，但其实只需要模拟，因为偶数的情况看似复杂，实际上只有 $2$ 类：</p>
<ul>
<li>全都在奇数或偶数格；</li>
<li>有一对相距两格且<strong>前者必须在奇数格上</strong>，而其余<strong>位置固定</strong>。</li>
</ul>
<p>这样就很好写了，忘记前缀和优化还挂了一发，真是服了。</p>
<p>时间复杂度 $\mathcal{O}(n)$。</p>
<h2 id="D-Chopping-Carrots"><a href="#D-Chopping-Carrots" class="headerlink" title="D. Chopping Carrots"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/D2">D. Chopping Carrots</a></h2><p>$\text{Solution:}$</p>
<p>简单版做法很多，由于对于 $\lfloor \dfrac{a_i}{p_i}\rfloor$，不同的取值最多只有 $2\sqrt{a_i}$，直接将所有取值都记下来，按<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7514">P7514 [省选联考 2021 A&#x2F;B 卷] 卡牌游戏</a>做即可。</p>
<p>复杂版无法支持我们存储所有取值，那么我们可以枚举 $\lfloor \dfrac{a_1}{p_1}\rfloor$ 的所有可能取值，记为 $b$，然后找到 $a_2\sim a_n$ 得到的小于等于 $b$ 的最大值和大于等于 $b$ 的最小值，再用双指针更新答案。时间复杂度 $\mathcal{O}(\sqrt{a_1}\times n\log n)$，自带大常数容易被卡常。</p>
<p>下面参考题解的 $\text{Solution 2}$，可以作为一个很好的 $\text{idea}$。</p>
<blockquote>
<p>假定 $v$ 为 $\lfloor \dfrac{a_i}{p_i}\rfloor$ 的最大值，则我们只需最大化 $\lfloor \dfrac{a_i}{p_i}\rfloor$ 的最小值。</p>
<p>考虑如果 $1\le a_i\le v$，则我们希望将 $p_i$ 取为 $1$，取 $2$ 及以上答案不优。</p>
<p>如果 $v+1\le a_i\le 2v$，则我们希望将 $p_i$ 取为 $2$，以此类推。</p>
<p>如果 $(u-1)\cdot v+1\le a_i \le u\cdot v$，则我们希望将 $p_i$ 取为 $u$。</p>
<p>但是我们如何对于满足 $(u-1)\cdot v+1\le a_i \le u\cdot v$ 的所有的 $a_i$ 计算最小值？不难发现，这些数的 $p_i$ 均取 $u$，所以我们只需求出这部分数的最小值即可。</p>
<p>记 $next_i$ 为所有 $a_i$ 中大于等于 $i$ 的最小值，这可以通过预处理轻松求出，这样，我们对于 $u&#x3D;1\sim k$，查询 $next_{(u-1)\cdot v+1}$ 就能得到。</p>
<p>两个重要的细节：</p>
<ol>
<li>如果存在 $a_i\ge(v+1)\cdot k$，那么 $v$ 就不可能作为最大值，直接跳过。</li>
<li>对于某个 $v$，我们只需要检查满足 $(u-1)\cdot v+1\le a_n$ 的 $u$，更大的没有意义。</li>
</ol>
<p>最后时间复杂度 $\mathcal{O}(\sum\limits_{i&#x3D;1}^{a_n}\dfrac{a_n}{a_i})&#x3D;\mathcal{O}(a_n \log a_n)$。</p>
</blockquote>
<p>这个复杂度居然连根号都不带，不得不说非常优秀。</p>
<h2 id="E-Qpwoeirut-and-Vertices"><a href="#E-Qpwoeirut-and-Vertices" class="headerlink" title="E. Qpwoeirut and Vertices"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/E">E. Qpwoeirut and Vertices</a></h2><p>$\text{Solution:}$</p>
<p>考虑将第 $i$ 条给定的边给定一个边权 $i$，然后跑一个最小生成树。通过最小生成树的性质，任意两点之间都有唯一路径，且涵盖的边权最大值尽可能小，正好符合我们的要求。</p>
<p>我们通过倍增求最近公共祖先，就能有两点之间的路径上的边权最大值，考虑如何拓展到 $[l,r]$ 区间任意两点。</p>
<p>由于我们只需对所有被经过的边取最大值，我们可以只去求相邻两点的最近公共祖先，就能涵盖到所有要求的路径。（想一想应该也可以理解）</p>
<p>最后用倍增就能得到答案。</p>
<p>时间复杂度 $\mathcal{O}(n\log n)$。</p>
<h1 id="Educational-Codeforces-Round-132-text-1709"><a href="#Educational-Codeforces-Round-132-text-1709" class="headerlink" title="Educational Codeforces Round 132$\text{(1709)}$"></a>Educational Codeforces Round 132$\text{(1709)}$</h1><p>比赛时间：$\text{2022&#x2F;7&#x2F;21 22:35}$</p>
<table>
<thead>
<tr>
<th align="center">$\text{Penalty}$</th>
<th align="center">$\texttt{A}$</th>
<th align="center">$\texttt{B}$</th>
<th align="center">$\texttt{C}$</th>
<th align="center">$\texttt{D}$</th>
<th align="center">$\texttt{E}$</th>
<th align="center">$\texttt{F}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$112$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+}$</td>
<td align="center">$\texttt{+1}$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$\text{00:03}$</td>
<td align="center">$\text{00:16}$</td>
<td align="center">$\text{00:33}$</td>
<td align="center">$\text{00:50}$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">补题</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">.</td>
</tr>
</tbody></table>
<h2 id="A-Three-Doors"><a href="#A-Three-Doors" class="headerlink" title="A. Three Doors"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/A">A. Three Doors</a></h2><p>$\text{Solution:}$</p>
<p><del>太难了，不会做。</del></p>
<h2 id="B-Also-Try-Minecraft"><a href="#B-Also-Try-Minecraft" class="headerlink" title="B. Also Try Minecraft"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/B">B. Also Try Minecraft</a></h2><p>$\text{Solution:}$</p>
<p>考虑记录一个前缀和后缀和表示到达某处的花费，然后就能 $O(1)$ 查询。</p>
<h2 id="C-Recover-an-RBS"><a href="#C-Recover-an-RBS" class="headerlink" title="C. Recover an RBS"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/C">C. Recover an RBS</a></h2><p>$\text{Solution;}$</p>
<p>考虑括号匹配的另一种理解：将左括号看作 <code>+1</code>，右括号看作 <code>-1</code>，保证所有前缀和大于等于 $0$，且总和为 $0$。</p>
<p>那么贪心地考虑，将左括号尽量地靠左，才能更有机会合法，那么我们找最优的两种即可。</p>
<h2 id="D-Rorororobot"><a href="#D-Rorororobot" class="headerlink" title="D. Rorororobot"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/D">D. Rorororobot</a></h2><p>$\text{Solution:}$</p>
<p>先跳到当前列的最高处，判断移动的列之间是否有被挡住的地方，即维护静态区间最大值，用了 st 表，时间复杂度 $\mathcal{O}{(n\log n)}$。</p>
<h2 id="E-XOR-Tree"><a href="#E-XOR-Tree" class="headerlink" title="E. XOR Tree"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/E">E. XOR Tree</a></h2><p>$\text{Solution:}$</p>
<p>记 $dist_u$ 表示 $1\sim u$ 路径异或和。</p>
<p>考虑 $(u,v)$ 之间路径的异或和 $dist_u\oplus dist_v\oplus a_{\text{lca(u,v)}}$。</p>
<p>可以证明如果只改变改变 $a_u$ 的取值，就能使以 $u$ 为根的子树<strong>不存在</strong>路径异或和为 $0$ 的点对。</p>
<p>我们可以对每一个节点开一个 set 表示以 $u$ 到 $u$ 子树内一点能表示出的所有的异或值，记为 $s_u$，然后对于 $u$ 的子节点 $v$，考虑是否有 $x\in s_u,y\in s_v,x\oplus y\oplus a_u&#x3D;0$，如果存在，说明我们必须修改 $a_u$，修改后清空 $s_u$；如果不存在，将 $s_v$ 合并入 $s_u$。</p>
<p>最后用 dsu on tree，将复杂度优化至 $\mathcal{O}(n\log^2 n)$。</p>
<p>$\text{Code: }$<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/submission/165254294">Submission #165254294 - Codeforces</a></p>

            <div id="vcomments"></div>
        </div>

        <div id = "toc">
        </div>

        <script>
            new Valine({
                el: '#vcomments',
                appId: 'CEGJD6I3uLgJeTF6fPsqgGmw-gzGzoHsz',
                appKey: 'R3wowhGv7IL3peB3tT06CjzS',
                visitor: true,
                master: '28a6ec927125219298a15dcb5c104f67'
            })
        </script>

    

</div>

</body>